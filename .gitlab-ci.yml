stages:
  - lint
  - test
  - build
  - publish
  - terraform
  - deploy
  - health_check
  - rollback

variables:
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  LATEST_TAG: $CI_REGISTRY_IMAGE:latest
  POSTGRES_USER: 'django_educational_demo_application'
  POSTGRES_PASSWORD: ''
  POSTGRES_DB: 'test_django_educational_demo_application'
  POSTGRES_HOST_AUTH_METHOD: trust

# Run linters: pre-commit-hooks, django-upgrade, ruff, djLint
linter_check:
  stage: lint
  image: python:3.13-slim
  before_script:
    - apt-get update
    - apt-get install -y git build-essential libpq-dev
    - pip install uv
  script:
    - uv venv
    - uv sync --locked
    - uv run pre-commit run --show-diff-on-failure --color=always --all-files

# Run pytest
test_pytest:
  stage: test
  image: ghcr.io/astral-sh/uv:python3.13-bookworm
  services:
    - postgres:15
  variables:
    DATABASE_URL: pgsql://$POSTGRES_USER:$POSTGRES_PASSWORD@postgres/$POSTGRES_DB
  before_script:
    - apt-get update && apt-get install -y build-essential libpq-dev
    - uv sync --locked
  script:
    - uv run pytest

# Build with kaniko
build_image:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - mkdir -p /kaniko/.docker
    - |
      cat > /kaniko/.docker/config.json <<EOF
      {
        "auths": {
          "$CI_REGISTRY": {
            "username": "$CI_REGISTRY_USER",
            "password": "$CI_REGISTRY_PASSWORD"
          }
        }
      }
      EOF
    - >
      /kaniko/executor
      --context "$CI_PROJECT_DIR"
      --dockerfile "$CI_PROJECT_DIR/Dockerfile"
      --destination "$IMAGE_TAG"
      --cache=true

# Publish to GitLab Container Registry
publish_latest:
  stage: publish
  image:
    name: gcr.io/go-containerregistry/crane:debug
    entrypoint: [""]
  needs:
    - build_image
  script:
    - crane auth login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD
    - "printf '' > previous.env"
    - |
      if crane digest "$LATEST_TAG" >/dev/null 2>&1; then
        crane tag "$LATEST_TAG" previous
        echo "PREVIOUS_IMAGE=$CI_REGISTRY_IMAGE:previous" >> previous.env
      else
        echo "PREVIOUS_IMAGE=" >> previous.env
      fi
    - crane tag "$IMAGE_TAG" latest
  artifacts:
    reports:
      dotenv: previous.env
    paths:
      - previous.env
  only:
    - main

# Create infra with terraform apply and prepare inventory from outputs
terraform_apply:
  stage: terraform
  image:
    name: hashicorp/terraform:1.6
    entrypoint: [""]
  variables:
    TF_VAR_cloud_id: "$CLOUD_ID"
    TF_VAR_folder_id: "$FOLDER_ID"
    TF_CLI_CONFIG_FILE: "$CI_PROJECT_DIR/infra/terraform.rc"
    AWS_DEFAULT_REGION: "ru-central1"
    AWS_EC2_METADATA_DISABLED: "true"
  before_script:
    - cd infra
    - |
      cat > "$TF_CLI_CONFIG_FILE" <<'EOF'
      provider_installation {
        network_mirror {
          url = "https://terraform-mirror.yandexcloud.net/"
          include = ["registry.terraform.io/*/*"]
        }
        direct {
          exclude = ["registry.terraform.io/*/*"]
        }
      }
      EOF
  script:
    - |
      if [ -z "$YC_SERVICE_ACCOUNT_KEY" ]; then
        echo "YC_SERVICE_ACCOUNT_KEY is not set"
        exit 1
      fi
      if [ -f "$YC_SERVICE_ACCOUNT_KEY" ]; then
        export TF_VAR_service_account_key_file="$YC_SERVICE_ACCOUNT_KEY"
      else
        export TF_VAR_service_account_key_file="/tmp/yc-sa-key.json"
        first_char="$(printf '%s' "$YC_SERVICE_ACCOUNT_KEY" | head -c 1)"
        if [ "$first_char" = "{" ]; then
          printf '%s' "$YC_SERVICE_ACCOUNT_KEY" > "$TF_VAR_service_account_key_file"
        else
          printf '%s' "$YC_SERVICE_ACCOUNT_KEY" | base64 -d > "$TF_VAR_service_account_key_file"
        fi
        chmod 600 "$TF_VAR_service_account_key_file"
      fi
    - |
      if [ -z "$SSH_PUBLIC_KEY" ]; then
        echo "SSH_PUBLIC_KEY is not set"
        exit 1
      fi
      if printf '%s' "$SSH_PUBLIC_KEY" | grep -qE '^(ssh-|ecdsa-|sk-).* '; then
        export TF_VAR_ssh_public_key="$SSH_PUBLIC_KEY"
      else
        export TF_VAR_ssh_public_key="$(printf '%s' "$SSH_PUBLIC_KEY" | base64 -d)"
      fi
    - |
      export TF_VAR_app_domain="${APP_DOMAIN:-app.example.com}"
      export TF_VAR_manage_dns="${MANAGE_DNS:-false}"
      export TF_VAR_dns_zone="${DNS_ZONE:-example.com}"
      export TF_VAR_dns_zone_resource_name="${DNS_ZONE_RESOURCE_NAME:-diploma-zone}"
    - export AWS_ACCESS_KEY_ID="${YC_STORAGE_ACCESS_KEY:-$AWS_ACCESS_KEY_ID}"
    - export AWS_SECRET_ACCESS_KEY="${YC_STORAGE_SECRET_KEY:-$AWS_SECRET_ACCESS_KEY}"
    - terraform init -backend-config="access_key=${AWS_ACCESS_KEY_ID}" -backend-config="secret_key=${AWS_SECRET_ACCESS_KEY}"
    - terraform validate
    - terraform plan -out=tfplan
    - terraform apply -auto-approve tfplan
    - terraform output -json > tf_outputs.json
    - APP_PUBLIC_IP="$(terraform output -raw app_public_ip)"
    - MONITORING_PUBLIC_IP="$(terraform output -raw monitoring_public_ip)"
    - DB_PRIVATE_IP="$(terraform output -raw db_private_ip)"
    - APP_DOMAIN="$(terraform output -raw app_domain)"
    - |
      cat > ../ansible/inventory/hosts.generated.ini <<EOF
      [app]
      app-vm ansible_host=${APP_PUBLIC_IP}

      [db]
      db-vm ansible_host=${DB_PRIVATE_IP} ansible_ssh_common_args='-o ProxyJump=ubuntu@${APP_PUBLIC_IP}'

      [monitoring]
      monitoring-vm ansible_host=${MONITORING_PUBLIC_IP}

      [all:vars]
      ansible_python_interpreter=/usr/bin/python3
      EOF
    - |
      cat > ../deploy.env <<EOF
      APP_PUBLIC_IP=${APP_PUBLIC_IP}
      MONITORING_PUBLIC_IP=${MONITORING_PUBLIC_IP}
      DB_PRIVATE_IP=${DB_PRIVATE_IP}
      APP_DOMAIN=${APP_DOMAIN}
      EOF
  artifacts:
    reports:
      dotenv: deploy.env
    paths:
      - infra/terraform.tfstate
      - infra/tf_outputs.json
      - ansible/inventory/hosts.generated.ini
      - deploy.env
  only:
    - main

# Deploy app, database and monitoring via Ansible
ansible_deploy:
  stage: deploy
  image: python:3.12-slim
  needs:
    - job: terraform_apply
      artifacts: true
  before_script:
    - pip install ansible
  script:
    - ansible-playbook -i ansible/inventory/hosts.generated.ini ansible/site.yml
        --extra-vars "image=$IMAGE_TAG
                      registry_url=$CI_REGISTRY
                      registry_user=$CI_REGISTRY_USER
                      registry_password=$CI_REGISTRY_PASSWORD
                      app_domain=$APP_DOMAIN
                      app_public_ip=$APP_PUBLIC_IP
                      db_host=$DB_PRIVATE_IP
                      db_name=${DB_NAME:-diploma}
                      db_user=${DB_USER:-diploma_user}
                      db_password=${DB_PASSWORD:-change-me-in-ci}
                      django_secret_key=${DJANGO_SECRET_KEY:-change-me-in-ci}
                      django_admin_url=${DJANGO_ADMIN_URL:-admin/}
                      caddy_acme_email=${TLS_ACME_EMAIL:-admin@$APP_DOMAIN}
                      app_subnet_cidr=${APP_SUBNET_CIDR:-10.10.1.0/24}"
  only:
    - main

# Perform health check of deployed app over HTTPS domain
health_check:
  stage: health_check
  image: curlimages/curl:latest
  needs:
    - job: terraform_apply
      artifacts: true
    - job: ansible_deploy
  script:
    - echo "Running HTTPS health check for $APP_DOMAIN..."
    - curl -fsS --retry 30 --retry-delay 10 --retry-all-errors "https://$APP_DOMAIN/health"
  only:
    - main

# Rollback to previous stable image from Container Registry
rollback:
  stage: rollback
  image: python:3.12-slim
  when: on_failure
  needs:
    - job: terraform_apply
      artifacts: true
    - job: publish_latest
      artifacts: true
  before_script:
    - pip install ansible
  script:
    - |
      if [ -z "$PREVIOUS_IMAGE" ]; then
        echo "PREVIOUS_IMAGE is not set, rollback skipped"
        exit 0
      fi
    - 'echo "Rollback to previous image: $PREVIOUS_IMAGE"'
    - ansible-playbook -i ansible/inventory/hosts.generated.ini ansible/site.yml
        --extra-vars "image=$PREVIOUS_IMAGE
                      registry_url=$CI_REGISTRY
                      registry_user=$CI_REGISTRY_USER
                      registry_password=$CI_REGISTRY_PASSWORD
                      app_domain=$APP_DOMAIN
                      app_public_ip=$APP_PUBLIC_IP
                      db_host=$DB_PRIVATE_IP
                      db_name=${DB_NAME:-diploma}
                      db_user=${DB_USER:-diploma_user}
                      db_password=${DB_PASSWORD:-change-me-in-ci}
                      django_secret_key=${DJANGO_SECRET_KEY:-change-me-in-ci}
                      django_admin_url=${DJANGO_ADMIN_URL:-admin/}
                      caddy_acme_email=${TLS_ACME_EMAIL:-admin@$APP_DOMAIN}
                      app_subnet_cidr=${APP_SUBNET_CIDR:-10.10.1.0/24}"
  only:
    - main
