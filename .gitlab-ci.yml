stages:
  - lint
  - test
  - build
  - publish
  - terraform
  - deploy
  - health_check
  - rollback

variables:
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  POSTGRES_USER: 'django_educational_demo_application'
  POSTGRES_PASSWORD: ''
  POSTGRES_DB: 'test_django_educational_demo_application'
  POSTGRES_HOST_AUTH_METHOD: trust

.deploy_env_rules: &deploy_env_rules
  - if: '$CI_COMMIT_BRANCH == "main"'
    variables:
      DEPLOY_ENV: "prod"
  - if: '$CI_COMMIT_BRANCH =~ /^(dev|develop)$/'
    variables:
      DEPLOY_ENV: "dev"
  - when: never

.deploy_env_manual_rules: &deploy_env_manual_rules
  - if: '$CI_COMMIT_BRANCH == "main"'
    when: manual
    allow_failure: true
    variables:
      DEPLOY_ENV: "prod"
  - if: '$CI_COMMIT_BRANCH =~ /^(dev|develop)$/'
    when: manual
    allow_failure: true
    variables:
      DEPLOY_ENV: "dev"
  - when: never

.deploy_env_failure_rules: &deploy_env_failure_rules
  - if: '$CI_COMMIT_BRANCH == "main"'
    when: on_failure
    variables:
      DEPLOY_ENV: "prod"
  - if: '$CI_COMMIT_BRANCH =~ /^(dev|develop)$/'
    when: on_failure
    variables:
      DEPLOY_ENV: "dev"
  - when: never

# Run linters: pre-commit-hooks, django-upgrade, ruff, djLint
linter_check:
  stage: lint
  image: ghcr.io/astral-sh/uv:python3.13-bookworm
  variables:
    UV_CACHE_DIR: $CI_PROJECT_DIR/.cache/uv
    PRE_COMMIT_HOME: $CI_PROJECT_DIR/.cache/pre-commit
  cache:
    key:
      files:
        - uv.lock
        - .pre-commit-config.yaml
    paths:
      - .cache/uv
      - .cache/pre-commit
  before_script:
    - apt-get update
    - apt-get install -y --no-install-recommends git
  script:
    - uv tool run pre-commit==4.5.1 run --show-diff-on-failure --color=always --all-files

# Run pytest
test_pytest:
  stage: test
  image: ghcr.io/astral-sh/uv:python3.13-bookworm
  needs:
    - job: linter_check
  services:
    - postgres:15
  variables:
    DATABASE_URL: pgsql://$POSTGRES_USER:$POSTGRES_PASSWORD@postgres/$POSTGRES_DB
  before_script:
    - apt-get update && apt-get install -y build-essential libpq-dev
    - uv sync --locked
  script:
    - uv run pytest

# Build with kaniko
build_image:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  needs:
    - job: test_pytest
  script:
    - mkdir -p /kaniko/.docker
    - |
      cat > /kaniko/.docker/config.json <<EOF
      {
        "auths": {
          "$CI_REGISTRY": {
            "username": "$CI_REGISTRY_USER",
            "password": "$CI_REGISTRY_PASSWORD"
          }
        }
      }
      EOF
    - >
      /kaniko/executor
      --context "$CI_PROJECT_DIR"
      --dockerfile "$CI_PROJECT_DIR/Dockerfile"
      --destination "$IMAGE_TAG"
      --cache=true

# Publish to GitLab Container Registry
publish_latest:
  stage: publish
  image:
    name: gcr.io/go-containerregistry/crane:debug
    entrypoint: [""]
  needs:
    - job: build_image
  script:
    - crane auth login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD
    - "printf '' > previous.env"
    - LATEST_ENV_TAG="$CI_REGISTRY_IMAGE:latest-${DEPLOY_ENV}"
    - PREVIOUS_ENV_TAG="$CI_REGISTRY_IMAGE:previous-${DEPLOY_ENV}"
    - |
      if crane digest "$LATEST_ENV_TAG" >/dev/null 2>&1; then
        crane tag "$LATEST_ENV_TAG" "previous-${DEPLOY_ENV}"
        echo "PREVIOUS_IMAGE=$PREVIOUS_ENV_TAG" >> previous.env
      else
        echo "PREVIOUS_IMAGE=" >> previous.env
      fi
    - crane tag "$IMAGE_TAG" "latest-${DEPLOY_ENV}"
    - echo "DEPLOY_ENV=${DEPLOY_ENV}" >> previous.env
  artifacts:
    reports:
      dotenv: previous.env
    paths:
      - previous.env
  rules: *deploy_env_rules

# Create infra with terraform apply and prepare inventory from outputs
terraform_apply:
  stage: terraform
  image:
    name: hashicorp/terraform:1.6
    entrypoint: [""]
  needs:
    - job: publish_latest
  variables:
    TF_VAR_cloud_id: "$CLOUD_ID"
    TF_VAR_folder_id: "$FOLDER_ID"
    TF_CLI_CONFIG_FILE: "$CI_PROJECT_DIR/infra/terraform.rc"
    AWS_DEFAULT_REGION: "ru-central1"
    AWS_EC2_METADATA_DISABLED: "true"
  before_script:
    - cd infra
    - |
      cat > "$TF_CLI_CONFIG_FILE" <<'EOF'
      provider_installation {
        network_mirror {
          url = "https://terraform-mirror.yandexcloud.net/"
          include = ["registry.terraform.io/*/*"]
        }
        direct {
          exclude = ["registry.terraform.io/*/*"]
        }
      }
      EOF
  script:
    - export TF_VAR_environment="${DEPLOY_ENV}"
    - |
      if [ -z "$YC_SERVICE_ACCOUNT_KEY" ]; then
        echo "YC_SERVICE_ACCOUNT_KEY is not set"
        exit 1
      fi
      if [ -f "$YC_SERVICE_ACCOUNT_KEY" ]; then
        export TF_VAR_service_account_key_file="$YC_SERVICE_ACCOUNT_KEY"
      else
        export TF_VAR_service_account_key_file="/tmp/yc-sa-key.json"
        first_char="$(printf '%s' "$YC_SERVICE_ACCOUNT_KEY" | head -c 1)"
        if [ "$first_char" = "{" ]; then
          printf '%s' "$YC_SERVICE_ACCOUNT_KEY" > "$TF_VAR_service_account_key_file"
        else
          printf '%s' "$YC_SERVICE_ACCOUNT_KEY" | base64 -d > "$TF_VAR_service_account_key_file"
        fi
        chmod 600 "$TF_VAR_service_account_key_file"
      fi
    - |
      if [ -z "$SSH_PUBLIC_KEY" ]; then
        echo "SSH_PUBLIC_KEY is not set"
        exit 1
      fi
      if printf '%s' "$SSH_PUBLIC_KEY" | grep -qE '^(ssh-|ecdsa-|sk-).* '; then
        export TF_VAR_ssh_public_key="$SSH_PUBLIC_KEY"
      else
        export TF_VAR_ssh_public_key="$(printf '%s' "$SSH_PUBLIC_KEY" | base64 -d)"
      fi
    - |
      if [ "${DEPLOY_ENV}" = "prod" ]; then
        default_app_domain="app.example.com"
      else
        default_app_domain="dev.app.example.com"
      fi
      export TF_VAR_app_domain="${APP_DOMAIN:-$default_app_domain}"
      export TF_VAR_manage_dns="${MANAGE_DNS:-false}"
      export TF_VAR_dns_zone="${DNS_ZONE:-example.com}"
      export TF_VAR_dns_zone_resource_name="${DNS_ZONE_RESOURCE_NAME:-diploma-zone-${DEPLOY_ENV}}"
    - export AWS_ACCESS_KEY_ID="${YC_STORAGE_ACCESS_KEY:-$AWS_ACCESS_KEY_ID}"
    - export AWS_SECRET_ACCESS_KEY="${YC_STORAGE_SECRET_KEY:-$AWS_SECRET_ACCESS_KEY}"
    - terraform init -backend-config="access_key=${AWS_ACCESS_KEY_ID}" -backend-config="secret_key=${AWS_SECRET_ACCESS_KEY}" -backend-config="key=${DEPLOY_ENV}/terraform.tfstate"
    - terraform validate
    - terraform plan -out=tfplan
    - terraform apply -auto-approve tfplan
    - terraform output -json > tf_outputs.json
    - APP_PUBLIC_IP="$(terraform output -raw app_public_ip)"
    - MONITORING_PUBLIC_IP="$(terraform output -raw monitoring_public_ip)"
    - DB_PRIVATE_IP="$(terraform output -raw db_private_ip)"
    - APP_DOMAIN="$(terraform output -raw app_domain)"
    - |
      cat > ../ansible/inventory/hosts.generated.ini <<EOF
      [app]
      app-vm ansible_host=${APP_PUBLIC_IP}

      [db]
      db-vm ansible_host=${DB_PRIVATE_IP} ansible_ssh_common_args='-o ProxyJump=ubuntu@${APP_PUBLIC_IP}'

      [monitoring]
      monitoring-vm ansible_host=${MONITORING_PUBLIC_IP}

      [all:vars]
      ansible_python_interpreter=/usr/bin/python3
      EOF
    - |
      cat > ../deploy.env <<EOF
      DEPLOY_ENV=${DEPLOY_ENV}
      APP_PUBLIC_IP=${APP_PUBLIC_IP}
      MONITORING_PUBLIC_IP=${MONITORING_PUBLIC_IP}
      DB_PRIVATE_IP=${DB_PRIVATE_IP}
      APP_DOMAIN=${APP_DOMAIN}
      EOF
  artifacts:
    reports:
      dotenv: deploy.env
    paths:
      - infra/terraform.tfstate
      - infra/tf_outputs.json
      - ansible/inventory/hosts.generated.ini
      - deploy.env
  environment:
    name: $DEPLOY_ENV
  rules: *deploy_env_rules


# Manually distroy terraform resources when needed
terraform_destroy:
  stage: terraform
  image:
    name: hashicorp/terraform:1.6
    entrypoint: [""]
  needs:
    - job: terraform_apply
  variables:
    TF_VAR_cloud_id: "$CLOUD_ID"
    TF_VAR_folder_id: "$FOLDER_ID"
    TF_CLI_CONFIG_FILE: "$CI_PROJECT_DIR/infra/terraform.rc"
    AWS_DEFAULT_REGION: "ru-central1"
    AWS_EC2_METADATA_DISABLED: "true"
  before_script:
    - cd infra
    - |
      cat > "$TF_CLI_CONFIG_FILE" <<'EOF'
      provider_installation {
        network_mirror {
          url = "https://terraform-mirror.yandexcloud.net/"
          include = ["registry.terraform.io/*/*"]
        }
        direct {
          exclude = ["registry.terraform.io/*/*"]
        }
      }
      EOF
  script:
    - export TF_VAR_environment="${DEPLOY_ENV}"
    - |
      if [ -z "$YC_SERVICE_ACCOUNT_KEY" ]; then
        echo "YC_SERVICE_ACCOUNT_KEY is not set"
        exit 1
      fi
      if [ -f "$YC_SERVICE_ACCOUNT_KEY" ]; then
        export TF_VAR_service_account_key_file="$YC_SERVICE_ACCOUNT_KEY"
      else
        export TF_VAR_service_account_key_file="/tmp/yc-sa-key.json"
        first_char="$(printf '%s' "$YC_SERVICE_ACCOUNT_KEY" | head -c 1)"
        if [ "$first_char" = "{" ]; then
          printf '%s' "$YC_SERVICE_ACCOUNT_KEY" > "$TF_VAR_service_account_key_file"
        else
          printf '%s' "$YC_SERVICE_ACCOUNT_KEY" | base64 -d > "$TF_VAR_service_account_key_file"
        fi
        chmod 600 "$TF_VAR_service_account_key_file"
      fi
    - |
      if [ -z "$SSH_PUBLIC_KEY" ]; then
        echo "SSH_PUBLIC_KEY is not set"
        exit 1
      fi
      if printf '%s' "$SSH_PUBLIC_KEY" | grep -qE '^(ssh-|ecdsa-|sk-).* '; then
        export TF_VAR_ssh_public_key="$SSH_PUBLIC_KEY"
      else
        export TF_VAR_ssh_public_key="$(printf '%s' "$SSH_PUBLIC_KEY" | base64 -d)"
      fi
    - |
      if [ "${DEPLOY_ENV}" = "prod" ]; then
        default_app_domain="app.example.com"
      else
        default_app_domain="dev.app.example.com"
      fi
      export TF_VAR_app_domain="${APP_DOMAIN:-$default_app_domain}"
      export TF_VAR_manage_dns="${MANAGE_DNS:-false}"
      export TF_VAR_dns_zone="${DNS_ZONE:-example.com}"
      export TF_VAR_dns_zone_resource_name="${DNS_ZONE_RESOURCE_NAME:-diploma-zone-${DEPLOY_ENV}}"
    - export AWS_ACCESS_KEY_ID="${YC_STORAGE_ACCESS_KEY:-$AWS_ACCESS_KEY_ID}"
    - export AWS_SECRET_ACCESS_KEY="${YC_STORAGE_SECRET_KEY:-$AWS_SECRET_ACCESS_KEY}"
    - terraform init -backend-config="access_key=${AWS_ACCESS_KEY_ID}" -backend-config="secret_key=${AWS_SECRET_ACCESS_KEY}" -backend-config="key=${DEPLOY_ENV}/terraform.tfstate"
    - terraform destroy -auto-approve
  environment:
    name: $DEPLOY_ENV
  rules: *deploy_env_manual_rules

# Deploy app, database and monitoring via Ansible
ansible_deploy:
  stage: deploy
  image: python:3.12-slim
  variables:
    ANSIBLE_CONFIG: ansible/ansible.cfg
    ANSIBLE_HOST_KEY_CHECKING: "False"
  needs:
    - job: terraform_apply
      artifacts: true
  before_script:
    - apt-get update
    - apt-get install -y openssh-client
    - pip install ansible
    - |
      if [ -z "$SSH_PRIVATE_KEY" ]; then
        echo "SSH_PRIVATE_KEY is not set"
        exit 1
      fi
      mkdir -p ~/.ssh
      chmod 700 ~/.ssh
      if [ -f "$SSH_PRIVATE_KEY" ]; then
        cp "$SSH_PRIVATE_KEY" ~/.ssh/id_rsa
      else
        if printf '%s' "$SSH_PRIVATE_KEY" | grep -q "BEGIN.*PRIVATE KEY"; then
          printf '%s' "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
        else
          printf '%s' "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/id_rsa
        fi
      fi
      chmod 600 ~/.ssh/id_rsa
  script:
    - ansible-playbook -i ansible/inventory/hosts.generated.ini ansible/site.yml
        --extra-vars "image=$IMAGE_TAG
                      registry_url=$CI_REGISTRY
                      registry_user=$CI_REGISTRY_USER
                      registry_password=$CI_REGISTRY_PASSWORD
                      app_domain=$APP_DOMAIN
                      app_public_ip=$APP_PUBLIC_IP
                      db_host=$DB_PRIVATE_IP
                      db_name=${DB_NAME:-diploma}
                      db_user=${DB_USER:-diploma_user}
                      db_password=${DB_PASSWORD:-change-me-in-ci}
                      django_secret_key=${DJANGO_SECRET_KEY:-change-me-in-ci}
                      django_admin_url=${DJANGO_ADMIN_URL:-admin/}
                      caddy_acme_email=${TLS_ACME_EMAIL:-admin@$APP_DOMAIN}
                      app_subnet_cidr=${APP_SUBNET_CIDR:-10.10.1.0/24}"
  environment:
    name: $DEPLOY_ENV
  rules: *deploy_env_rules

# Perform health check of deployed app over HTTPS domain
health_check:
  stage: health_check
  image: curlimages/curl:latest
  needs:
    - job: terraform_apply
      artifacts: true
    - job: ansible_deploy
  script:
    - |
      echo "Running HTTPS health check for ${APP_DOMAIN}..."
      set +e
      curl -fsS --retry 6 --retry-delay 10 --retry-all-errors "https://${APP_DOMAIN}/health"
      rc=$?
      set -e

      if [ "$rc" -eq 0 ]; then
        echo "Running HTTPS homepage check for ${APP_DOMAIN}..."
        curl -fsS --retry 6 --retry-delay 10 --retry-all-errors "https://${APP_DOMAIN}/"
        exit 0
      fi

      if [ "$rc" -ne 6 ]; then
        echo "HTTPS health check failed with curl exit code ${rc}"
        exit "$rc"
      fi

      if [ -z "${APP_PUBLIC_IP:-}" ]; then
        echo "APP_PUBLIC_IP is empty, cannot run fallback health check"
        exit 1
      fi

      echo "DNS for ${APP_DOMAIN} is not resolvable yet. Fallback to HTTP health check by IP ${APP_PUBLIC_IP}."
      curl -fsS --retry 30 --retry-delay 10 --retry-all-errors "http://${APP_PUBLIC_IP}/health"
      echo "Running fallback HTTP homepage check by IP ${APP_PUBLIC_IP}."
      curl -fsS --retry 30 --retry-delay 10 --retry-all-errors "http://${APP_PUBLIC_IP}/"
  environment:
    name: $DEPLOY_ENV
  rules: *deploy_env_rules

# Rollback to previous stable image from Container Registry
rollback:
  stage: rollback
  image: python:3.12-slim
  variables:
    ANSIBLE_CONFIG: ansible/ansible.cfg
    ANSIBLE_HOST_KEY_CHECKING: "False"
  needs:
    - job: health_check
    - job: terraform_apply
      artifacts: true
    - job: publish_latest
      artifacts: true
  before_script:
    - apt-get update
    - apt-get install -y openssh-client
    - pip install ansible
    - |
      if [ -z "$SSH_PRIVATE_KEY" ]; then
        echo "SSH_PRIVATE_KEY is not set"
        exit 1
      fi
      mkdir -p ~/.ssh
      chmod 700 ~/.ssh
      if [ -f "$SSH_PRIVATE_KEY" ]; then
        cp "$SSH_PRIVATE_KEY" ~/.ssh/id_rsa
      else
        if printf '%s' "$SSH_PRIVATE_KEY" | grep -q "BEGIN.*PRIVATE KEY"; then
          printf '%s' "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
        else
          printf '%s' "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/id_rsa
        fi
      fi
      chmod 600 ~/.ssh/id_rsa
  script:
    - |
      if [ -z "$PREVIOUS_IMAGE" ]; then
        echo "PREVIOUS_IMAGE is not set, rollback skipped"
        exit 0
      fi
    - 'echo "Rollback to previous image: $PREVIOUS_IMAGE"'
    - ansible-playbook -i ansible/inventory/hosts.generated.ini ansible/site.yml
        --extra-vars "image=$PREVIOUS_IMAGE
                      registry_url=$CI_REGISTRY
                      registry_user=$CI_REGISTRY_USER
                      registry_password=$CI_REGISTRY_PASSWORD
                      app_domain=$APP_DOMAIN
                      app_public_ip=$APP_PUBLIC_IP
                      db_host=$DB_PRIVATE_IP
                      db_name=${DB_NAME:-diploma}
                      db_user=${DB_USER:-diploma_user}
                      db_password=${DB_PASSWORD:-change-me-in-ci}
                      django_secret_key=${DJANGO_SECRET_KEY:-change-me-in-ci}
                      django_admin_url=${DJANGO_ADMIN_URL:-admin/}
                      caddy_acme_email=${TLS_ACME_EMAIL:-admin@$APP_DOMAIN}
                      app_subnet_cidr=${APP_SUBNET_CIDR:-10.10.1.0/24}"
  environment:
    name: $DEPLOY_ENV
  rules: *deploy_env_failure_rules
