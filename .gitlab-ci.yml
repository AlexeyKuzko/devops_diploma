stages:
  - lint
  - test
  - build
  - deploy

variables:
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  POSTGRES_USER: 'django_educational_demo_application'
  POSTGRES_PASSWORD: ''
  POSTGRES_DB: 'test_django_educational_demo_application'
  POSTGRES_HOST_AUTH_METHOD: trust

# ---------------- LINT ----------------
linter_check_ruff:
  stage: lint
  image: python:3.13-slim
  variables:
    PRE_COMMIT_HOME: ${CI_PROJECT_DIR}/.cache/pre-commit
  cache:
    paths:
      - ${PRE_COMMIT_HOME}
  before_script:
    - apt-get update && apt-get install -y build-essential libpq-dev git
    - pip install -q uv
    - uv --version
    - uv venv
    - uv pip install -q pre-commit pre-commit-uv
  script:
    - uv sync --locked
    - uv run pre-commit run --show-diff-on-failure --color=always --all-files

# ---------------- TEST ----------------
test_with_pytest:
  stage: test
  image: ghcr.io/astral-sh/uv:python3.13-bookworm
  services:
    - postgres:15
  variables:
    DATABASE_URL: pgsql://$POSTGRES_USER:$POSTGRES_PASSWORD@postgres/$POSTGRES_DB
  before_script:
    - apt-get update && apt-get install -y build-essential libpq-dev
    - uv sync --locked
  script:
    - uv run pytest

# ---------------- BUILD ----------------
build_with_kaniko:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  variables:
    DOCKER_CONFIG: /kaniko/.docker/
  script:
    - mkdir -p /kaniko/.docker
    - |
      cat > /kaniko/.docker/config.json <<EOF
      {
        "auths": {
          "$CI_REGISTRY": {
            "username": "$CI_REGISTRY_USER",
            "password": "$CI_REGISTRY_PASSWORD"
          }
        }
      }
      EOF
    - >
      /kaniko/executor
      --context "$CI_PROJECT_DIR"
      --dockerfile "$CI_PROJECT_DIR/Dockerfile"
      --destination "$IMAGE_TAG"
      --destination "$CI_REGISTRY_IMAGE:latest"
      --cache=true


# ---------------- DEPLOY ----------------
deploy_with_compose:
  stage: deploy
  image: alpine:latest
  only:
    - main

  needs:
    - build_with_kaniko

  variables:
    APP_CONTAINER_NAME: diploma-demo
    DEPLOY_PATH: /home/$VM_USER/app

  before_script:
    - apk add --no-cache openssh docker-cli docker-cli-compose rsync curl

  script:
    - echo "$SSH_PRIVATE_KEY" > id_rsa
    - chmod 600 id_rsa

    # 1. Гарантируем существование директории
    - ssh -o StrictHostKeyChecking=no -i id_rsa $VM_USER@$VM_HOST "mkdir -p /home/$VM_USER/app"

    # 2. Копируем compose (всегда перезаписываем)
    - scp -o StrictHostKeyChecking=no -i id_rsa docker-compose.prod.yml $VM_USER@$VM_HOST:/home/$VM_USER/app/

    # 3. Основной deploy
    - |
      ssh -o StrictHostKeyChecking=no -i id_rsa $VM_USER@$VM_HOST "
        set -Eeuo pipefail

        DEPLOY_PATH=/home/$VM_USER/app
        cd \$DEPLOY_PATH

        echo \"$CI_REGISTRY_PASSWORD\" | docker login $CI_REGISTRY \
          -u \"$CI_REGISTRY_USER\" --password-stdin

        echo \"IMAGE_TAG=$IMAGE_TAG\" > .deploy_env
        echo \"APP_CONTAINER_NAME=$APP_CONTAINER_NAME\" >> .deploy_env

        # Сохраняем предыдущий образ (если есть)
        if docker ps -a --format '{{.Names}}' | grep -q '^$APP_CONTAINER_NAME$'; then
          docker inspect $APP_CONTAINER_NAME \
            --format='{{.Config.Image}}' > .previous_image || true
        fi

        # Тянем новый образ
        docker compose -f docker-compose.prod.yml \
          --env-file .deploy_env pull

        # Перезапускаем
        docker compose -f docker-compose.prod.yml \
          --env-file .deploy_env up -d --remove-orphans

        # Ждём healthcheck (до 60 сек)
        echo 'Waiting for healthcheck...'
        for i in {1..12}; do
          STATUS=\$(docker inspect \
            --format='{{.State.Health.Status}}' \
            $APP_CONTAINER_NAME 2>/dev/null || echo 'unknown')

          if [ \"\$STATUS\" = \"healthy\" ]; then
            echo 'Container healthy'
            exit 0
          fi

          sleep 5
        done

        echo 'Healthcheck failed. Rolling back...'

        if [ -f .previous_image ]; then
          PREV_IMAGE=\$(cat .previous_image)

          echo \"IMAGE_TAG=\$PREV_IMAGE\" > .deploy_env
          echo \"APP_CONTAINER_NAME=$APP_CONTAINER_NAME\" >> .deploy_env

          docker compose -f docker-compose.prod.yml \
            --env-file .deploy_env up -d --remove-orphans

          echo 'Rollback completed'
        fi

        exit 1
      "
